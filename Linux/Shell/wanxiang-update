#!/usr/bin/env bash

set -euo pipefail

#### 配置 Rime 部署目录 ####
# 支持相对路径、绝对路径、拓展变量
# 例如 "/home/user/.local/share/fcitx5/rime"
# 例如 "$HOME/.local/share/fcitx5/rime"
# 例如 "${XDG_DATA_HOME:-$HOME/.local/share}/fcitx5/rime"

DEPLOY_DIR=""

######### 配置结束 #########

# 全局变量
SCHEMA_REPO="https://github.com/amzxyz/rime_wanxiang"
GRAM_REPO="https://github.com/amzxyz/RIME-LMDG"
TOOLS_REPO="https://github.com/expoli/rime-wanxiang-update-tools"
SCHEMA_API="https://api.github.com/repos/amzxyz/rime_wanxiang"
GRAM_API="https://api.github.com/repos/amzxyz/RIME-LMDG"
TOOLS_API="https://api.github.com/repos/expoli/rime-wanxiang-update-tools"
FUZHU_LIST=("all" "base" "flypy" "hanxin" "jdh" "moqi" "tiger" "wubi" "zrm")
TEMP_DIR=$(mktemp -d /tmp/wanxiang-update-XXXXXX)
UPDATE_TOOLS_VERSION="DEFAULT_UPDATE_TOOLS_VERSION_TAG"
declare -A SCHEMA_MAP=(
  ["moqi"]="rime-wanxiang-moqi-fuzhu.zip"
  ["flypy"]="rime-wanxiang-flypy-fuzhu.zip"
  ["zrm"]="rime-wanxiang-zrm-fuzhu.zip"
  ["jdh"]="rime-wanxiang-jdh-fuzhu.zip"
  ["tiger"]="rime-wanxiang-tiger-fuzhu.zip"
  ["wubi"]="rime-wanxiang-wubi-fuzhu.zip"
  ["hanxin"]="rime-wanxiang-hanxin-fuzhu.zip"
  ["all"]="rime-wanxiang-all-fuzhu.zip"
  ["base"]="rime-wanxiang-base.zip"
)
declare -A DICT_MAP=(
  ["moqi"]="1-pro-moqi-fuzhu-dicts.zip"
  ["flypy"]="2-pro-flypy-fuzhu-dicts.zip"
  ["zrm"]="3-pro-zrm-fuzhu-dicts.zip"
  ["jdh"]="4-pro-jdh-fuzhu-dicts.zip"
  ["tiger"]="5-pro-tiger-fuzhu-dicts.zip"
  ["wubi"]="6-pro-wubi-fuzhu-dicts.zip"
  ["hanxin"]="7-pro-hanxin-fuzhu-dicts.zip"
  ["all"]="8-pro-all-dicts.zip"
  ["base"]="9-base-dicts.zip"
)

# 日志与错误处理
log() {
  local red="\033[0;31m" green="\033[0;32m" yellow="\033[0;33m" nc="\033[0m"
  local level="$1" color="$nc"
  case "$level" in
  INFO) color="$green" ;;
  WARN) color="$yellow" ;;
  ERROR) color="$red" ;;
  esac
  shift
  printf "${color}[%s] %s${nc}\n" "$level" "$*"
}
error_exit() {
  log ERROR "$*"
  cleanup
  exit 1
}
cleanup() {
  if [[ -d "$TEMP_DIR" ]]; then
    rm -rf "$TEMP_DIR" || log WARN "清理缓存文件失败"
  fi
}
deps_check() {
  for _cmd in curl jq unzip sha256sum; do
    command -v "$_cmd" >/dev/null || error_exit "缺少必要依赖：$_cmd"
  done
}
fuzhu_check() {
  local fuzhu_check="$1"
  for _fuzhu in "${FUZHU_LIST[@]}"; do
    if [[ "$fuzhu_check" == "$_fuzhu" ]]; then
      return 0
    fi
  done
  return 1
}
script_check() {
  if [[ "$UPDATE_TOOLS_VERSION" =~ ^"DEFAULT" ]]; then
    log WARN "你似乎正在使用源文件！"
    log WARN "请从 $TOOLS_REPO/releases/latest 页面下载正式版！"
    error_exit "终止操作"
  fi
  log INFO "工具当前版本 $UPDATE_TOOLS_VERSION"
  log INFO "正在检查本工具是否有更新"
  local local_version remote_version
  local_version="$UPDATE_TOOLS_VERSION"
  remote_version=$(
    curl -sL --connect-timeout 10 $TOOLS_API/releases |
      jq -r '.[].tag_name' | grep -vE "rc" | sort -rV | head -n 1
  )
  if [[ "$remote_version" > "$local_version" ]]; then
    log WARN "检测到工具最新版本为: $remote_version, 建议更新后继续"
    log WARN "你可从该链接下载: $GH_DL/$UPDATE_TOOLS_REPO/releases/tag/$remote_version"
  else
    log INFO "工具已是最新版本"
  fi
}

update_schema() {
  local fuzhu="$1" gram="$2"
  # 获取本地版本号
  local local_version remote_version
  if [[ -f "$DEPLOY_DIR/lua/wanxiang.lua" ]]; then
    local_version=$(grep "wanxiang.version" "$DEPLOY_DIR/lua/wanxiang.lua" | awk -F '"' '{print $2}')
  else
    local_version="0"
  fi
  log INFO "当前方案文件版本号为 v$local_version"
  # 获取远程版本号
  remote_version=$(
    curl -sL --connect-timeout 10 $SCHEMA_API/releases |
      jq -r '.[].tag_name' | grep -vE "dict-nightly" | sort -rV | head -n 1
  )
  if [[ "$remote_version" > "v$local_version" ]]; then
    log INFO "方案文件最新版本号为 $remote_version, 以下内容为更新日志"
    local changelog
    changelog=$(
      curl -sL --connect-timeout 10 $SCHEMA_API/releases |
        jq -r --arg version "$remote_version" '.[] |
        select(.tag_name == $version ) | .body'
    )
    echo -e "$changelog" | sed -n '/## 📝 更新日志/,/## 🚀 下载引导/p' | head -n -1
    sleep 5
    log INFO "开始更新方案文件，正在下载文件"
    curl -L --connect-timeout 10 -o "$TEMP_DIR/${SCHEMA_MAP[$fuzhu]}" \
      "$SCHEMA_REPO/releases/download/$remote_version/${SCHEMA_MAP[$fuzhu]}"
    log INFO "正在验证文件完整性"
    local local_sha256sum remote_sha256sum
    local_sha256sum=$(sha256sum "$TEMP_DIR/${SCHEMA_MAP[$fuzhu]}" | awk '{print $1}')
    remote_sha256sum=$(
      curl -sL --connect-timeout 10 $SCHEMA_API/releases |
        jq -r --arg version "$remote_version" --arg fuzhu "$fuzhu" '.[] |
        select(.tag_name == $version) | .assets.[] |
        select(.name | test($fuzhu)) | .digest' | awk -F ':' '{print $2}'
    )
    [[ "$local_sha256sum" == "$remote_sha256sum" ]] || error_exit "方案文件下载出错，请重试！"
    log INFO "验证成功，开始更新方案文件"
    unzip -q "$TEMP_DIR/${SCHEMA_MAP[$fuzhu]}" -d "$TEMP_DIR/${SCHEMA_MAP[$fuzhu]%.zip}"
    rm -r "$TEMP_DIR/${SCHEMA_MAP[$fuzhu]%.zip}"/{简纯.trime.yaml,custom_phrase.txt,squirrel.yaml,weasel.yaml}
    local exclude_file
    while IFS= read -r _line; do
      exclude_file="$_line"
      if [[ ! -e "$DEPLOY_DIR/$exclude_file" ]]; then
        log WARN "项目 $DEPLOY_DIR/$exclude_file 不存在，跳过备份！"
      else
        cp -rf "$DEPLOY_DIR/$exclude_file" "$TEMP_DIR/${SCHEMA_MAP[$fuzhu]%.zip}/$exclude_file"
      fi
    done <"$DEPLOY_DIR/user_exclude_file.txt"
    # 单独处理语法模型
    [[ "$gram" == "true" ]] || cp -rf "$DEPLOY_DIR/wanxiang-lts-zh-hans.gram" \
      "$TEMP_DIR/${SCHEMA_MAP[$fuzhu]%.zip}/wanxiang-lts-zh-hans.gram"
    rm -rf "${DEPLOY_DIR:?}"
    cp -rf "$TEMP_DIR/${SCHEMA_MAP[$fuzhu]%.zip}" "${DEPLOY_DIR}"
    log INFO "方案文件更新成功"
  else
    log INFO "方案文件无需更新"
  fi
}
update_dict() {
  local fuzhu="$1"
  log INFO "正在下载最新词典文件"
  curl -L --connect-timeout 10 -o "$TEMP_DIR/${DICT_MAP[$fuzhu]}" \
    "$SCHEMA_REPO/releases/download/dict-nightly/${DICT_MAP[$fuzhu]}"
  log INFO "正在验证文件完整性"
  local local_sha256sum remote_sha256sum
  local_sha256sum=$(sha256sum "$TEMP_DIR/${DICT_MAP[$fuzhu]}" | awk '{print $1}')
  remote_sha256sum=$(
    curl -sL --connect-timeout 10 $SCHEMA_API/releases |
      jq -r --arg version "dict-nightly" --arg fuzhu "$fuzhu" '.[] |
      select(.tag_name == $version ) | .assets.[] |
      select(.name | test($fuzhu)) | .digest' | awk -F ':' '{print $2}'
  )
  [[ "$local_sha256sum" == "$remote_sha256sum" ]] || error_exit "词典文件下载出错，请重试！"
  log INFO "验证成功，开始更新词典文件"
  unzip -q "$TEMP_DIR/${DICT_MAP[$fuzhu]}" -d "$TEMP_DIR"
  local dict_dir
  dict_dir="${DICT_MAP[$fuzhu]:2}"
  dict_dir="${dict_dir%.zip}"
  cp -rf "$TEMP_DIR/$dict_dir"/* "${DEPLOY_DIR}/dicts"
  log INFO "词典文件更新成功"
}
update_gram() {
  log INFO "正在下载最新语法模型"
  curl -L --connect-timeout 10 -o "$TEMP_DIR/wanxiang-lts-zh-hans.gram" \
    "$GRAM_REPO/releases/download/LTS/wanxiang-lts-zh-hans.gram"
  log INFO "正在验证文件完整性"
  local local_sha256sum remote_sha256sum
  local_sha256sum=$(sha256sum "$TEMP_DIR/wanxiang-lts-zh-hans.gram" | awk '{print $1}')
  remote_sha256sum=$(
    curl -sL --connect-timeout 10 $GRAM_API/releases |
      jq -r --arg version "LTS" --arg gramname "wanxiang-lts-zh-hans.gram" '.[] |
      select(.tag_name == $version) | .assets.[] |
      select(.name == $gramname) | .digest' | awk -F ':' '{print $2}'
  )
  [[ "$local_sha256sum" == "$remote_sha256sum" ]] || error_exit "语法模型下载出错，请重试！"
  log INFO "验证成功，开始语法模型文件"
  cp -rf "$TEMP_DIR/wanxiang-lts-zh-hans.gram" "${DEPLOY_DIR}/wanxiang-lts-zh-hans.gram"
  log INFO "语法模型更新成功"
}

main() {
  # 脚本退出清理临时目录
  trap cleanup EXIT
  # 检查是否为root用户
  if [[ "$EUID" -eq 0 ]]; then
    error_exit "请不要使用 root 身份运行该脚本！"
  fi
  # 检查必要的依赖
  deps_check
  # 脚本自检
  script_check
  # 处理用户输入
  local schema="" fuzhu="" dict="false" gram="false"
  # 解析命令行参数
  while [[ "$#" -gt 0 ]]; do
    case $1 in
    --schema)
      if [[ -n "$schema" ]]; then
        error_exit "选项 scheam 需要参数！"
      else
        shift
      fi
      if [[ "$1" != "base" && "$1" != "pro" ]]; then
        error_exit "选项 scheam 的参数只能为 base 或 pro"
      else
        schema="$1"
      fi
      ;;
    --fuzhu)
      if [[ -n "$fuzhu" ]]; then
        error_exit "选项 fuzhu 需要参数！"
      else
        shift
      fi
      if fuzhu_check "$1"; then
        fuzhu="$1"
      else
        error_exit "选项 fuzhu 的参数只能为 ${FUZHU_LIST[*]} 其中之一"
      fi
      ;;
    --dict)
      dict="true"
      ;;
    --gram)
      gram="true"
      ;;
    *)
      log WARN "你可能错误的使用了该脚本"
      log WARN "请前往 GitHub 页面阅读 Readme"
      log WARN "直达链接：$TOOLS_REPO/blob/main/Linux/Shell/README.md"
      error_exit "参数输入错误: $1"
      ;;
    esac
    shift
  done
  # 判断是否设置了部署目录
  if [[ -n "$DEPLOY_DIR" ]]; then
    if [[ ! -d "$DEPLOY_DIR" ]]; then
      log WARN "部署目录 $DEPLOY_DIR 不存在，你要创建它吗？"
      read -rp "请输入 YES 或 NO (区分大小写) " _check
      if [[ "$_check" == "YES" ]]; then
        log WARN "你真的要创建该目录吗？你确定你的设置正确吗？"
        read -rp "请输入 YES 或 NO (区分大小写) " _check_again
        [[ "$_check_again" == "YES" ]] || error_exit "用户终止操作"
        mkdir -p "$DEPLOY_DIR"
      else
        error_exit "用户终止操作"
      fi
    fi
  else
    error_exit "请设置部署目录！"
  fi
  # 排除项目列表文件是否存在
  if [[ ! -f "$DEPLOY_DIR/user_exclude_file.txt" ]]; then
    log WARN "你没有设置排除项目列表！"
    log WARN "你需要创建的文件为 $DEPLOY_DIR/user_exclude_file.txt"
    log WARN "请在该文件中写入你需要排除的项目，每行一个"
    log WARN "如果你确实不需要排除任何文件，请创建一个空文件来抑制该警告"
    log WARN "更多内容请参阅：$TOOLS_REPO/blob/main/Linux/Shell/README.md"
    error_exit "$DEPLOY_DIR/user_exclude_file.txt 文件不存在"
  fi
  # 检查 schema 和 fuzhu 是否同时存在
  if [[ -n "$schema" && -z "$fuzhu" ]]; then
    error_exit "选项 schema 与选项 fuzhu 必须同时使用"
  fi
  # 检查 dict 和 fuzhu 是否同时存在
  if [[ "$dict" == "true" && -z "$fuzhu" ]]; then
    error_exit "选项 dict 与选项 fuzhu 必须同时使用"
  fi
  # 检查当 schema 为 base 时，fuzhu 是否也为 base
  if [[ "$schema" == "base" && "$fuzhu" != "base" ]]; then
    error_exit "当选项 schema 为 base 时，选项 fuzhu 必须为 base"
  fi
  [[ -z "$schema" ]] || update_schema "$fuzhu" "$gram"
  [[ "$dict" == "false" ]] || update_dict "$fuzhu"
  [[ "$gram" == "false" ]] || update_gram
  # 提示用户重新进行部署
  log INFO "更新完成，请重新部署 rime"
  # Fcitx5+Plasma (KDE) 用户可取消以下注释来自动部署
  # if command -v qdbus6 >/dev/null; then
  #   qdbus6 org.fcitx.Fcitx5 /controller org.fcitx.Fcitx.Controller1.SetConfig "fcitx://config/addon/rime/deploy" ""
  # fi
}

main "$@"
